<!doctype html>
<html>
<body>
<head>
    <meta charset='utf-8'>
    <title>filter_cluster</title>
    <script src='https://d3js.org/d3.v4.min.js'></script>
    <script src="{{ url_for('static', filename='js/jsLouvain.js') }}" type="text/javascript"></script>
    <script>
        const width = 1000;
        const height = 500;

        const padding = 0;
        const clusterPadding = 30;

        const maxRadius = 10;

        var color = d3.scaleOrdinal(d3.schemeCategory10)
            .domain(d3.range(10));

        var clusters = new Array(64);
        const defaultRadius = 10;

        function louvain_cluster() {
            d3.json("http://127.0.0.1:5000/getCorrData", function(error, graph) {
                    var filters_num = Object.keys(graph).length;
                    nodes = new Array();
                    nodeData = new Array();
                    linkData = new Array();
                    for (var i = 0; i < filters_num; i++) {
                        nodeData[i] = i;
                        node = {};
                        nodes[i] = node;
                    }

                    var i = 0;
                    for (var x = 0; x < filters_num; x++) {
                        for (var y = x + 1; y < filters_num; y++){
                            link = {source: x, target: y, weight: parseFloat(graph[x][y])};
                            linkData[i++] = link;
                        }
                    }

                    links = linkData;

                    console.log(linkData);

                    var community = jLouvain()
                        .nodes(nodeData)
                        .edges(linkData);
                    var result = community();
                    console.log(result);
                    console.log(nodes);

                    for (var i = 0; i < nodes.length; i++) {
                        node = nodes[i]
                        node.radius = defaultRadius;
                        node.cluster = result[i];
                    }

                    nodes.forEach(function (node) {
                        const radius = node.radius;
                        const clusterID = node.cluster;
                        if (!clusters[clusterID] || (radius > clusters[clusterID].r)) {
                            clusters[clusterID] = node;
                        }
                    });

                    console.log(nodes);


                    // var child = document.getElementsByTagName("svg");
                    // if (child.length > 0) {
                    //     child[0].parentNode.removeChild(child[0])
                    // }

                    var forceCollide = d3.forceCollide()
                        .radius(function(d) { return d.radius + 1.5; })
                        .iterations(1);

                    var force = d3.forceSimulation()
                        .nodes(nodes)
                        .force("center", d3.forceCenter())
                        .force("collide", forceCollide)
                        .force("cluster", forceCluster)
                        .force("gravity", d3.forceManyBody(10))
                        .force("x", d3.forceX().strength(.2))
                        .force("y", d3.forceY().strength(.2))
                        .on("tick", tick);

                    var svg = d3.select("body").append("svg")
                        .attr("width", width)
                        .attr("height", height)
                      .append('g')
                        .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

                    var circle = svg.selectAll("circle")
                        .data(nodes)
                      .enter().append("circle")
                        .attr("r", function(d) { return d.radius; })
                        .style("fill", function(d) { return color(d.cluster); })
                    //    TODO: Update for v4
                    //    .call(force.drag);

                    function tick() {
                      circle
                          .attr("cx", function(d) { return d.x; })
                          .attr("cy", function(d) { return d.y; });
                    }

                    function forceCluster(alpha) {
                      for (var i = 0, n = nodes.length, node, cluster, k = alpha * 1; i < n; ++i) {
                        node = nodes[i];
                        cluster = clusters[node.cluster];
                        node.vx -= (node.x - cluster.x) * k;
                        node.vy -= (node.y - cluster.y) * k;
                        }
                    }
            });
        }

        function log() {
            var d = new Date();
            var t=d.toLocaleTimeString();
            console.log(t);
        }
    </script>
    <script>
        louvain_cluster();
        // var r = setInterval(function(){transition()}, 2000);
        // d3.json("http://127.0.0.1:5000/getCorrData", function(error, graph) {
        //     console.log(graph)
        // });
    </script>
</head>
<body>


</body>
</html>